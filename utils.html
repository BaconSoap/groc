<!DOCTYPE html><html lang="en"><head><title>utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="utils"><meta name="groc-project-path" content="lib/utils.coffee"><meta name="groc-github-url" content="https://github.com/nevir/groc"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="document"><div class="meta"><div class="file-path"><a href="https://github.com/nevir/groc/blob/master/lib/utils.coffee">projectPath</a></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Miscellaneous code fragments reside here.</p></div></div><div class="code"><div class="wrapper"><span class="nv">Utils =</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Detect and return the language that a given file is written in.</p>

<p>The language is also annotated with a name property, matching the laguages key in LANGUAGES.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getLanguage: </span><span class="nf">(filePath) -&gt;</span>
    <span class="nx">unless</span> <span class="nx">@_languageDetectionCache</span><span class="o">?</span>
      <span class="vi">@_languageDetectionCache = </span><span class="p">[]</span>

      <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">language</span> <span class="k">of</span> <span class="nx">LANGUAGES</span>
        <span class="nv">language.name = </span><span class="nx">name</span>

        <span class="k">for</span> <span class="nx">matcher</span> <span class="k">in</span> <span class="nx">language</span><span class="p">.</span><span class="nx">nameMatchers</span>
          <span class="nx">@_languageDetectionCache</span><span class="p">.</span><span class="nx">push</span> <span class="p">[</span><span class="nx">matcher</span><span class="p">,</span> <span class="nx">language</span><span class="p">]</span>

    <span class="nv">baseName = </span><span class="nx">path</span><span class="p">.</span><span class="nx">basename</span> <span class="nx">filePath</span>

    <span class="k">for</span> <span class="nx">pair</span> <span class="k">in</span> <span class="nx">@_languageDetectionCache</span>
      <span class="k">return</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nx">baseName</span><span class="p">.</span><span class="nx">match</span> <span class="nx">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Map a list of file paths to relative target paths by stripping prefixes off of them.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">mapFiles: </span><span class="nf">(resolveRoot, files, stripPrefixes) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Ensure that we're dealing with absolute paths across the board</p></div></div><div class="code"><div class="wrapper">    <span class="nv">files = </span><span class="nx">files</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(f) -&gt;</span> <span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span> <span class="nx">resolveRoot</span><span class="p">,</span> <span class="nx">f</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>And that the strip prefixes all end with a /, to avoid a target path being absolute.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">stripPrefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">map</span> <span class="nf">(p) -&gt;</span> <span class="s2">&quot;#{path.resolve resolveRoot, p}/&quot;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Prefixes are stripped in order of most specific to least (# of directories deep)</p></div></div><div class="code"><div class="wrapper">    <span class="nv">prefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">sort</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="nv">result = </span><span class="p">{}</span>

    <span class="k">for</span> <span class="nx">absPath</span> <span class="k">in</span> <span class="nx">files</span>
      <span class="nv">file = </span><span class="nx">absPath</span>

      <span class="k">for</span> <span class="nx">stripPath</span> <span class="k">in</span> <span class="nx">stripPrefixes</span>
        <span class="nv">file = </span><span class="nx">file</span><span class="p">[</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">..]</span> <span class="k">if</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">==</span> <span class="nx">stripPath</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We also strip the extension under the assumption that the consumer of this path map is going
to substitute in their own.  Plus, if they care about the extension, they can get it from
the keys of the map.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">result</span><span class="p">[</span><span class="nx">absPath</span><span class="p">]</span> <span class="o">=</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="o">-</span><span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">).</span><span class="nx">length</span><span class="p">]</span>

    <span class="nx">result</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Attempt to guess strip prefixes for a given set of arguments.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">guessStripPrefixes: </span><span class="nf">(arguments) -&gt;</span>
    <span class="nv">result = </span><span class="p">[]</span>
    <span class="k">for</span> <span class="nx">arg</span> <span class="k">in</span> <span class="nx">arguments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Most globs look something like dir/<em>*/</em>.ext, so strip up to the leading *</p></div></div><div class="code"><div class="wrapper">      <span class="nv">arg = </span><span class="nx">arg</span><span class="p">.</span><span class="nx">replace</span> <span class="sr">/\*.*$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span>

      <span class="nx">result</span><span class="p">.</span><span class="nx">push</span> <span class="nx">arg</span> <span class="k">if</span> <span class="nx">arg</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>For now, we try to avoid ambiguous situations by guessing the FIRST directory given.  The
assumption is that you don't want merged paths, but probably did specify the most important
source directory first.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="nx">_</span><span class="p">(</span><span class="nx">result</span><span class="p">).</span><span class="nx">uniq</span><span class="p">()[...</span><span class="mi">1</span><span class="p">]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>How many directories deep is a given path?</p></div></div><div class="code"><div class="wrapper">  <span class="nv">pathDepth: </span><span class="nf">(path) -&gt;</span>
    <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\/\\]/</span><span class="p">).</span><span class="nx">length</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Split source code into segments (comment + code pairs)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">splitSource: </span><span class="nf">(data, language) -&gt;</span>
    <span class="nv">lines = </span><span class="nx">data</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/\r?\n/</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Always strip shebangs - but don't shift it off the array to avoid the perf hit of walking the
array to update indices.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#!&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Special case: If the language is comments-only, we can skip pygments</p></div></div><div class="code"><div class="wrapper">    <span class="k">return</span> <span class="p">[</span><span class="k">new</span> <span class="nx">@Segment</span> <span class="p">[],</span> <span class="nx">lines</span><span class="p">]</span> <span class="k">if</span> <span class="nx">language</span><span class="p">.</span><span class="nx">commentsOnly</span>

    <span class="nv">segments = </span><span class="p">[]</span>
    <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We only support single line comments for the time being.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">singleLineMatcher = </span><span class="err">///^\s*(#{language.singleLineComment.join(&#39;|&#39;)})\s?(.*)$///</span>

    <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">lines</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Match that line to the language's single line comment syntax.</p>

<p>However, we treat all comments beginning with } as inline code commentary.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">singleLineMatcher</span>

      <span class="c1">#} For example, this comment should be treated as part of our code.</span>
      <span class="k">if</span> <span class="nx">match</span><span class="o">?</span> <span class="o">and</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;}&#39;</span>
        <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
          <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
          <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

      <span class="k">else</span>
        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

    <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
    <span class="nx">segments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Just a convenient prototype for building segments</p></div></div><div class="code"><div class="wrapper">  <span class="nv">Segment: </span><span class="k">class</span> <span class="nx">Segment</span>
    <span class="nv">constructor: </span><span class="nf">(code=[], comments=[]) -&gt;</span>
      <span class="vi">@code     = </span><span class="nx">code</span>
      <span class="vi">@comments = </span><span class="nx">comments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their code through <a href="http://pygments.org/">Pygments</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">highlightCode: </span><span class="nf">(segments, language, callback) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Don't bother spawning pygments if we have nothing to highlight</p></div></div><div class="code"><div class="wrapper">    <span class="nv">numCodeLines = </span><span class="nx">segments</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span> <span class="nf">(c,s) -&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="p">),</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">numCodeLines</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="nx">segment</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="s1">&#39;&#39;</span>

      <span class="k">return</span> <span class="nx">callback</span><span class="p">()</span>

    <span class="nv">pygmentize = </span><span class="nx">childProcess</span><span class="p">.</span><span class="nx">spawn</span> <span class="s1">&#39;pygmentize&#39;</span><span class="p">,</span> <span class="p">[</span>
      <span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="nx">language</span><span class="p">.</span><span class="nx">pygmentsLexer</span>
      <span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;html&#39;</span>
      <span class="s1">&#39;-O&#39;</span><span class="p">,</span> <span class="s1">&#39;encoding=utf-8,tabsize=2&#39;</span>
    <span class="p">]</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stderr</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data)  -&gt;</span> <span class="nx">callback</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="nf">(error) -&gt;</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We'll just split the output at the end.  pygmentize doesn't stream its output, and a given
source file is small enough that it shouldn't matter.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="s1">&#39;&#39;</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;exit&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">args</span><span class="p">...)</span> <span class="o">=&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>pygments spits it out wrapped in <code>&lt;div class="highlight"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</code>.  We want to
manage the styling ourselves, so remove that.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">result = </span><span class="nx">result</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;&lt;/pre&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Extract our segments from the pygmentized source.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">highlighted = </span><span class="s2">&quot;\n#{result}\n&quot;</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/.*&lt;span.*SEGMENT DIVIDER&lt;\/span&gt;.*/</span>

      <span class="k">if</span> <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>
        <span class="nv">error = </span><span class="k">new</span> <span class="nb">Error</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">format</span> <span class="s1">&#39;pygmentize rendered %d of %d segments; expected to be equal&#39;</span><span class="p">,</span>
          <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>

        <span class="nv">error.pygmentsOutput   = </span><span class="nx">result</span>
        <span class="nv">error.failedHighlights = </span><span class="nx">highlighted</span>
        <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Attach highlighted source to the highlightedCode property of a Segment.</p></div></div><div class="code"><div class="wrapper">      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="nx">highlighted</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Rather than spawning pygments for each segment, we stream it all in, separated by 'magic'
comments so that we can split the highlighted source back into segments.</p>

<p>To further complicate things, pygments doesn't let us cheat with indentation-aware languages:
We have to match the indentation of the line following the divider comment.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">mergedCode = </span><span class="s1">&#39;&#39;</span>
    <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
      <span class="nv">segmentCode = </span><span class="nx">segment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">join</span> <span class="s1">&#39;\n&#39;</span>

      <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Double negative: match characters that are spaces but not newlines</p></div></div><div class="code"><div class="wrapper">        <span class="nv">indentation = </span><span class="nx">segmentCode</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^[^\S\n]+/</span><span class="p">)</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s1">&#39;&#39;</span>
        <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s2">&quot;\n#{indentation}#{language.singleLineComment[0]} SEGMENT DIVIDER\n&quot;</span>

      <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="nx">segmentCode</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">write</span> <span class="nx">mergedCode</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their comments through
<a href="https://github.com/coreyti/showdown">showdown</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">markdownComments: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">converter = </span><span class="k">new</span> <span class="nx">showdown</span><span class="p">.</span><span class="nx">Showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">()</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">markdown = </span><span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span> <span class="s1">&#39;\n&#39;</span>
        <span class="nv">headers  = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>showdown generates header ids by lowercasing &amp; dropping non-word characters.  We'd like
something a bit more readable.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">markdown = </span><span class="nx">@gsub</span> <span class="nx">markdown</span><span class="p">,</span> <span class="sr">/&lt;h(\d) id=&quot;[^&quot;]+&quot;&gt;([^&lt;]+)&lt;\/h\d&gt;/g</span><span class="p">,</span> <span class="p">(</span><span class="nx">match</span><span class="p">)</span> <span class="o">=&gt;</span>
          <span class="nv">header =</span>
            <span class="nv">level: </span><span class="nb">parseInt</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nv">title: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="nv">slug: </span> <span class="nx">@slugifyTitle</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

          <span class="nv">header.isFileHeader = </span><span class="kc">true</span> <span class="k">if</span> <span class="nx">header</span><span class="p">.</span><span class="nx">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">segmentIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span>

          <span class="nx">headers</span><span class="p">.</span><span class="nx">push</span> <span class="nx">header</span>

          <span class="s2">&quot;&lt;h#{header.level} id=\&quot;#{header.slug}\&quot;&gt;#{header.title}&lt;/h#{header.level}&gt;&quot;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We attach the rendered markdown to the comment</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.markdownedComments = </span><span class="nx">markdown</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>As well as the extracted headers to aid in outline building.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.headers = </span><span class="nx">headers</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Sometimes you just don't want any of them hanging around.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">trimBlankLines: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[\r\n]+/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\r\n]+$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Given a title, convert it into a URL-friendly slug.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">slugifyTitle: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\s\-\_]+/</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span> <span class="nf">(s) -&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">).</span><span class="nx">join</span> <span class="s1">&#39;-&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>replacer is a function that is given the match object, and returns the string to replace with.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">gsub: </span><span class="nf">(string, matcher, replacer) -&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="s1">&#39;You must pass a global RegExp to gsub!&#39;</span> <span class="nx">unless</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">global</span><span class="o">?</span>

    <span class="nv">result = </span><span class="s1">&#39;&#39;</span>
    <span class="nv">matcher.lastIndex = </span><span class="mi">0</span>
    <span class="nv">furthestIndex = </span><span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">exec</span> <span class="nx">string</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...</span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">replacer</span> <span class="nx">match</span>

      <span class="nv">furthestIndex = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">lastIndex</span>

    <span class="nx">result</span> <span class="o">+</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...]</span></div></div></div></div></body></html>