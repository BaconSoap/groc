<!DOCTYPE html><html lang="en"><head><title>utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="lidoc-relative-root" content=""><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div class="segment"><div class="comments"><div class="wrapper"><p>Miscellaneous code fragments reside here.</p></div></div><div class="code"><div class="wrapper"><span class="nv">Utils =</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Map a list of file paths to relative target paths by stripping prefixes off of them.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">mapFiles: </span><span class="nf">(files, stripPrefixes) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Prefixes are stripped in order of most specific to least (# of directories deep)</p></div></div><div class="code"><div class="wrapper">    <span class="nv">prefixes = </span><span class="nx">stripPrefixes</span><span class="p">.</span><span class="nx">sort</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="o">-</span> <span class="nx">@pathDepth</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

    <span class="nv">result = </span><span class="p">{}</span>

    <span class="k">for</span> <span class="nx">absPath</span> <span class="k">in</span> <span class="nx">files</span>
      <span class="nv">file = </span><span class="nx">absPath</span>

      <span class="k">for</span> <span class="nx">stripPath</span> <span class="k">in</span> <span class="nx">stripPrefixes</span>
        <span class="nv">file = </span><span class="nx">file</span><span class="p">[</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">..]</span> <span class="k">if</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="nx">stripPath</span><span class="p">.</span><span class="nx">length</span><span class="p">]</span> <span class="o">==</span> <span class="nx">stripPath</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We also strip the extension under the assumption that the consumer of this path map is going
to substitute in their own.  Plus, if they care about the extension, they can get it from
the keys of the map.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">result</span><span class="p">[</span><span class="nx">absPath</span><span class="p">]</span> <span class="o">=</span> <span class="nx">file</span><span class="p">[</span><span class="mi">0</span><span class="p">...</span><span class="o">-</span><span class="nx">path</span><span class="p">.</span><span class="nx">extname</span><span class="p">(</span><span class="nx">file</span><span class="p">).</span><span class="nx">length</span><span class="p">]</span>

    <span class="nx">result</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>How many directories deep is a given path?</p></div></div><div class="code"><div class="wrapper">  <span class="nv">pathDepth: </span><span class="nf">(path) -&gt;</span>
    <span class="nx">path</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\/\\]/</span><span class="p">).</span><span class="nx">length</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Split source code into segments (comment + code pairs)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">splitSource: </span><span class="nf">(data, language) -&gt;</span>
    <span class="nv">lines = </span><span class="nx">data</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/\r?\n/</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Always strip shebangs - but don't shift it off the array to avoid the perf hit of walking the
array to update indices.</p></div></div><div class="code"><div class="wrapper">    <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="nx">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;#!&#39;</span>

    <span class="nv">segments = </span><span class="p">[]</span>
    <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We only support single line comments for the time being.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">singleLineMatcher = </span><span class="err">///^\s*(#{language.singleLineComment.join(&#39;|&#39;)})\s?(.*)$///</span>

    <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">lines</span>
      <span class="k">if</span> <span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">singleLineMatcher</span>
        <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
          <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
          <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
      <span class="k">else</span>
        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

    <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
    <span class="nx">segments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Just a convenient prototype for building segments</p></div></div><div class="code"><div class="wrapper">  <span class="nv">Segment: </span><span class="k">class</span> <span class="nx">Segment</span>
    <span class="nv">constructor: </span><span class="nf">(code=[], comments=[]) -&gt;</span>
      <span class="vi">@code     = </span><span class="nx">code</span>
      <span class="vi">@comments = </span><span class="nx">comments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their code through <a href="http://pygments.org/">Pygments</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">highlightCode: </span><span class="nf">(segments, language, callback) -&gt;</span>
    <span class="nv">pygmentize = </span><span class="nx">childProcess</span><span class="p">.</span><span class="nx">spawn</span> <span class="s1">&#39;pygmentize&#39;</span><span class="p">,</span> <span class="p">[</span>
      <span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="nx">language</span><span class="p">.</span><span class="nx">pygmentsLexer</span>
      <span class="s1">&#39;-f&#39;</span><span class="p">,</span> <span class="s1">&#39;html&#39;</span>
      <span class="s1">&#39;-O&#39;</span><span class="p">,</span> <span class="s1">&#39;encoding=utf-8,tabsize=2&#39;</span>
    <span class="p">]</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stderr</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data)  -&gt;</span> <span class="nx">callback</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="nf">(error) -&gt;</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We'll just split the output at the end.  pygmentize doesn't stream its output, and a given
source file is small enough that it shouldn't matter.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="s1">&#39;&#39;</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Rather than spawning pygments for each segment, we stream it all in, separated by 'magic'
comments so that we can split the highlighted source back into segments.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">segmentDivider = </span><span class="s2">&quot;\n#{language.singleLineComment[0]} SEGMENT DIVIDER\n&quot;</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">addListener</span> <span class="s1">&#39;exit&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">args</span><span class="p">...)</span> <span class="o">=&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>pygments spits it out wrapped in <div class="highlight"><pre>...</pre></div>.  We want to
manage the styling ourselves, so remove that.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">result = </span><span class="nx">result</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s1">&#39;&lt;/pre&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Extract our segments from the pygmentized source.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">highlighted = </span><span class="s2">&quot;\n#{result}\n&quot;</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/\n[^\n]*SEGMENT DIVIDER[^\n]*\n/</span>

      <span class="k">if</span> <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>
        <span class="nv">error = </span><span class="k">new</span> <span class="nb">Error</span> <span class="nx">util</span><span class="p">.</span><span class="nx">format</span> <span class="s1">&#39;pygmentize rendered %d of %d segments; expected to be equal&#39;</span><span class="p">,</span>
          <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>

        <span class="nv">error.pygmentsOutput = </span><span class="nx">result</span>
        <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Attach highlighted source to the highlightedCode property of a Segment.</p></div></div><div class="code"><div class="wrapper">      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="nx">highlighted</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>pygmentize does not stream, so we need delimeters</p></div></div><div class="code"><div class="wrapper">    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">write</span> <span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">join</span> <span class="s2">&quot;\n&quot;</span> <span class="k">for</span> <span class="nx">s</span> <span class="k">in</span> <span class="nx">segments</span><span class="p">).</span><span class="nx">join</span> <span class="nx">segmentDivider</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their comments through
<a href="https://github.com/coreyti/showdown">showdown</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">markdownComments: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">converter = </span><span class="k">new</span> <span class="nx">showdown</span><span class="p">.</span><span class="nx">Showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">()</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">markdown = </span><span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span> <span class="s1">&#39;\n&#39;</span>
        <span class="nv">headers  = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>showdown generates header ids by lowercasing &amp; dropping non-word characters.  We'd like
something a bit more readable.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">markdown = </span><span class="nx">@gsub</span> <span class="nx">markdown</span><span class="p">,</span> <span class="sr">/&lt;h(\d) id=&quot;[^&quot;]+&quot;&gt;([^&lt;]+)&lt;\/h\d&gt;/g</span><span class="p">,</span> <span class="p">(</span><span class="nx">match</span><span class="p">)</span> <span class="o">=&gt;</span>
          <span class="nv">header =</span>
            <span class="nv">level: </span><span class="nb">parseInt</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nv">title: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="nv">slug: </span> <span class="nx">@slugifyTitle</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

          <span class="nx">headers</span><span class="p">.</span><span class="nx">push</span> <span class="nx">header</span>

          <span class="s2">&quot;&lt;h#{header.level} id=\&quot;#{header.slug}\&quot;&gt;#{header.title}&lt;/h#{header.level}&gt;&quot;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We attach the rendered markdown to the comment</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.markdownedComments = </span><span class="nx">markdown</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>As well as the extracted headers to aid in outline building.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.headers = </span><span class="nx">headers</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Given an array of markdowned segments, convert their list of headers into a hierarchical
outline (table of contents!)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">outlineHeaders: </span><span class="nf">(segments) -&gt;</span>
    <span class="nv">headers = </span><span class="nx">segments</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span> <span class="nf">(a, s) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span> <span class="nx">s</span><span class="p">.</span><span class="nx">headers</span> <span class="p">),</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="p">[]</span> <span class="nx">unless</span> <span class="nx">headers</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nv">result = </span><span class="p">[]</span>
    <span class="nv">stack  = </span><span class="p">[]</span>

    <span class="k">for</span> <span class="nx">header</span> <span class="k">in</span> <span class="nx">headers</span>
      <span class="nv">node = header: </span><span class="nx">header</span><span class="p">,</span> <span class="nv">children: </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Unwind the stack until we get to the first node that is at a lower level value - we want to
append to that guy</p></div></div><div class="code"><div class="wrapper">      <span class="nx">stack</span><span class="p">.</span><span class="nx">pop</span><span class="p">()</span> <span class="k">while</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">?</span><span class="p">.</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span> <span class="o">&gt;=</span> <span class="nx">header</span><span class="p">.</span><span class="nx">level</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Are we starting a new top level node?</p></div></div><div class="code"><div class="wrapper">      <span class="k">if</span> <span class="nx">stack</span><span class="p">.</span><span class="nx">length</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span> <span class="nx">node</span>
      <span class="k">else</span>
        <span class="nx">stack</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">children</span><span class="p">.</span><span class="nx">push</span> <span class="nx">node</span>

      <span class="nx">stack</span><span class="p">.</span><span class="nx">push</span> <span class="nx">node</span>

    <span class="nx">result</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Sometimes you just don't want any of them hanging around.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">trimBlankLines: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[\r\n]+/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\r\n]+$/</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Given a title, convert it into a URL-friendly slug.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">slugifyTitle: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/\s+/</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span> <span class="nf">(s) -&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w]/g</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">).</span><span class="nx">join</span> <span class="s1">&#39;-&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>replacer is a function that is given the match object, and returns the string to replace with.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">gsub: </span><span class="nf">(string, matcher, replacer) -&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="s1">&#39;You must pass a global RegExp to gsub!&#39;</span> <span class="nx">unless</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">global</span><span class="o">?</span>

    <span class="nv">result = </span><span class="s1">&#39;&#39;</span>
    <span class="nv">matcher.lastIndex = </span><span class="mi">0</span>
    <span class="nv">furthestIndex = </span><span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">exec</span> <span class="nx">string</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...</span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">replacer</span> <span class="nx">match</span>

      <span class="nv">furthestIndex = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">lastIndex</span>

    <span class="nx">result</span> <span class="o">+</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...]</span></div></div></div></body></html>