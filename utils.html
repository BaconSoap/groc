<!DOCTYPE html><html lang="en"><head><title>utils</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content=""><meta name="groc-document-path" content="utils"><meta name="groc-project-path" content="lib/utils.coffee"><meta name="groc-github-url" content="https://github.com/nevir/groc"><link rel="stylesheet" type="text/css" media="all" href="assets/style.css"><script type="text/javascript" src="assets/behavior.js"></script><body><div id="meta"><div class="file-path"><a href="https://github.com/nevir/groc/blob/master/lib/utils.coffee">lib/utils.coffee</a></div></div><div id="document"><div class="segment"><div class="comments"><div class="wrapper"><p>Miscellaneous code fragments reside here.</p></div></div><div class="code"><div class="wrapper"><span class="nv">Utils =</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Escape regular expression characters in a string</p></div></div><div class="code"><div class="wrapper">  <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Code from http://zetafleet.com/ via http://simonwillison.net/2006/Jan/20/escape/</p></div></div><div class="code"><div class="wrapper">  <span class="nv">regexpEscape: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[-[\]{}()*+?.,\\^$|#\s]/g</span><span class="p">,</span> <span class="s">&#39;\\$&amp;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Detect and return the language that a given file is written in.</p></div></div><div class="code"><div class="wrapper">  <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>The language is also annotated with a name property, matching the laguages key in LANGUAGES.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">getLanguage: </span><span class="nf">(filePath) -&gt;</span>
    <span class="nx">unless</span> <span class="nx">@_languageDetectionCache</span><span class="o">?</span>
      <span class="vi">@_languageDetectionCache = </span><span class="p">[]</span>

      <span class="k">for</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">language</span> <span class="k">of</span> <span class="nx">LANGUAGES</span>
        <span class="nv">language.name = </span><span class="nx">name</span>

        <span class="k">for</span> <span class="nx">matcher</span> <span class="k">in</span> <span class="nx">language</span><span class="p">.</span><span class="nx">nameMatchers</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>If the matcher is a string, we assume that it's a file extension.  Stick it in a regex:</p></div></div><div class="code"><div class="wrapper">          <span class="nv">matcher = </span><span class="sr">///</span><span class="c1">#{@regexpEscape matcher}$/// if _.isString matcher</span>

          <span class="sr">@_languageDetectionCache.push [matcher, language]</span>

<span class="sr">    baseName = path.basename filePath</span>

<span class="sr">    for pair in @_languageDetectionCache</span>
<span class="sr">      return pair[1] if baseName.match pair[0]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Map a list of file paths to relative target paths by stripping prefixes off of them.</p></div></div><div class="code"><div class="wrapper">  <span class="sr">mapFiles: (resolveRoot, files, stripPrefixes) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Ensure that we're dealing with absolute paths across the board</p></div></div><div class="code"><div class="wrapper">    <span class="sr">files = files.map (f) -&gt; path.resolve resolveRoot, f</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>And that the strip prefixes all end with a /, to avoid a target path being absolute.</p></div></div><div class="code"><div class="wrapper">    <span class="sr">stripPrefixes = stripPrefixes.map (p) -&gt; path.join( &quot;</span><span class="c1">#{path.resolve resolveRoot, p}#{utils.CompatibilityHelpers.pathSep}&quot; )</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Prefixes are stripped in order of most specific to least (# of directories deep)</p></div></div><div class="code"><div class="wrapper">    <span class="sr">prefixes = stripPrefixes.sort (a,b) =&gt; @pathDepth(b) - @pathDepth(a)</span>

<span class="sr">    result = {}</span>

<span class="sr">    for absPath in files</span>
<span class="sr">      file = absPath</span>

<span class="sr">      for stripPath in stripPrefixes</span>
<span class="sr">        file = file[stripPath.length..] if file[0...stripPath.length] == stripPath</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We also strip the extension under the assumption that the consumer of this path map is going
to substitute in their own.  Plus, if they care about the extension, they can get it from
the keys of the map.</p></div></div><div class="code"><div class="wrapper">      <span class="sr">result[absPath] = if not path.extname(file) then file else file[0...-path.extname(file).length]</span>

<span class="sr">    result</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Attempt to guess strip prefixes for a given set of arguments.</p></div></div><div class="code"><div class="wrapper">  <span class="sr">guessStripPrefixes: (args) -&gt;</span>
<span class="sr">    result = []</span>
<span class="sr">    for arg in args</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Most globs look something like dir/<em>*/</em>.ext, so strip up to the leading *</p></div></div><div class="code"><div class="wrapper">      <span class="sr">arg = arg.replace /\*.*$/, &#39;&#39;</span>

<span class="sr">      result.push arg if arg.slice(-1) == utils.CompatibilityHelpers.pathSep</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>For now, we try to avoid ambiguous situations by guessing the FIRST directory given.  The
assumption is that you don't want merged paths, but probably did specify the most important
source directory first.</p></div></div><div class="code"><div class="wrapper">    <span class="sr">result = _(result).uniq()[...1]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>How many directories deep is a given path?</p></div></div><div class="code"><div class="wrapper">  <span class="sr">pathDepth: (path) -&gt;</span>
<span class="sr">    path.split(/[\/\\]/).length</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Split source code into segments (comment + code pairs)</p></div></div><div class="code"><div class="wrapper">  <span class="sr">splitSource: (data, language, options={}) -&gt;</span>
<span class="sr">    lines = data.split /\r?\n/</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Always strip shebangs - but don't shift it off the array to avoid the perf hit of walking the
array to update indices.</p></div></div><div class="code"><div class="wrapper">    <span class="sr">lines[0] = &#39;&#39; if lines[0][0..1] == &#39;</span><span class="c1">#!&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Special case: If the language is comments-only, we can skip pygments</p></div></div><div class="code"><div class="wrapper">    <span class="sr">return [new @Segment [], lines] if language.commentsOnly</span>

<span class="sr">    segments = []</span>
<span class="sr">    currSegment = new @Segment</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Enforced whitespace after the comment token</p></div></div><div class="code"><div class="wrapper">    <span class="sr">whitespaceMatch = if options.requireWhitespaceAfterToken then &#39;\\s&#39; else &#39;\\s?&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We only support single line comments for the time being.</p></div></div><div class="code"><div class="wrapper">    <span class="sr">singleLineMatcher = ///</span><span class="o">^</span><span class="err">\</span><span class="nx">s</span><span class="o">*</span><span class="p">(</span><span class="c1">#{language.singleLineComment.join(&#39;|&#39;)})#{whitespaceMatch}(.*)$///</span>

    <span class="k">for</span> <span class="nx">line</span> <span class="k">in</span> <span class="nx">lines</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Match that line to the language's single line comment syntax.</p></div></div><div class="code"><div class="wrapper">      <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>However, we treat all comments beginning with } as inline code commentary.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">match = </span><span class="nx">line</span><span class="p">.</span><span class="nx">match</span> <span class="nx">singleLineMatcher</span>

      <span class="c1">#} For example, this comment should be treated as part of our code.</span>
      <span class="k">if</span> <span class="nx">match</span><span class="o">?</span> <span class="o">and</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;}&#39;</span>
        <span class="k">if</span> <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span>
          <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
          <span class="nv">currSegment = </span><span class="k">new</span> <span class="nx">@Segment</span>

        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

      <span class="k">else</span>
        <span class="nx">currSegment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">push</span> <span class="nx">line</span>

    <span class="nx">segments</span><span class="p">.</span><span class="nx">push</span> <span class="nx">currSegment</span>
    <span class="nx">segments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Just a convenient prototype for building segments</p></div></div><div class="code"><div class="wrapper">  <span class="nv">Segment: </span><span class="k">class</span> <span class="nx">Segment</span>
    <span class="nv">constructor: </span><span class="nf">(code=[], comments=[]) -&gt;</span>
      <span class="vi">@code     = </span><span class="nx">code</span>
      <span class="vi">@comments = </span><span class="nx">comments</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their code through <a href="http://pygments.org/">Pygments</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">highlightCode: </span><span class="nf">(segments, language, callback) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Don't bother spawning pygments if we have nothing to highlight</p></div></div><div class="code"><div class="wrapper">    <span class="nv">numCodeLines = </span><span class="nx">segments</span><span class="p">.</span><span class="nx">reduce</span> <span class="p">(</span> <span class="nf">(c,s) -&gt;</span> <span class="nx">c</span> <span class="o">+</span> <span class="nx">s</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">length</span> <span class="p">),</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="nx">numCodeLines</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="k">for</span> <span class="nx">segment</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="s">&#39;&#39;</span>

      <span class="k">return</span> <span class="nx">callback</span><span class="p">()</span>

    <span class="nv">pygmentize = </span><span class="nx">childProcess</span><span class="p">.</span><span class="nx">spawn</span> <span class="s">&#39;pygmentize&#39;</span><span class="p">,</span> <span class="p">[</span>
      <span class="s">&#39;-l&#39;</span><span class="p">,</span> <span class="nx">language</span><span class="p">.</span><span class="nx">pygmentsLexer</span>
      <span class="s">&#39;-f&#39;</span><span class="p">,</span> <span class="s">&#39;html&#39;</span>
      <span class="s">&#39;-O&#39;</span><span class="p">,</span> <span class="s">&#39;encoding=utf-8,tabsize=2&#39;</span>
    <span class="p">]</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stderr</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="nf">(data)  -&gt;</span> <span class="nx">callback</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;error&#39;</span><span class="p">,</span> <span class="nf">(error) -&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>This appears to only occur when pygmentize is missing:</p></div></div><div class="code"><div class="wrapper">      <span class="nx">utils</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nx">error</span> <span class="s">&quot;Unable to find &#39;pygmentize&#39; on your PATH.  Please install pygments.&quot;</span>
      <span class="nx">utils</span><span class="p">.</span><span class="nx">Logger</span><span class="p">.</span><span class="nx">info</span> <span class="s">&#39;&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Lack of pygments is a one time setup task, we don't feel bad about killing the process
off until the user does so.  It's a hard requirement.</p></div></div><div class="code"><div class="wrapper">      <span class="nx">process</span><span class="p">.</span><span class="nx">exit</span> <span class="mi">1</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We'll just split the output at the end.  pygmentize doesn't stream its output, and a given
source file is small enough that it shouldn't matter.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdout</span><span class="p">.</span><span class="nx">addListener</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">toString</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>v0.8 changed exit/close event semantics.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">match = </span><span class="nx">process</span><span class="p">.</span><span class="nx">version</span><span class="p">.</span><span class="nx">match</span> <span class="sr">/v(\d+\.\d+)/</span>
    <span class="nv">closeEvent = </span><span class="k">if</span> <span class="nb">parseFloat</span><span class="p">(</span><span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.8</span> <span class="k">then</span> <span class="s">&#39;exit&#39;</span> <span class="k">else</span> <span class="s">&#39;close&#39;</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">addListener</span> <span class="nx">closeEvent</span><span class="p">,</span> <span class="p">(</span><span class="nx">args</span><span class="p">...)</span> <span class="o">=&gt;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>pygments spits it out wrapped in <code>&lt;div class="highlight"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</code>.  We want to
manage the styling ourselves, so remove that.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">result = </span><span class="nx">result</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="s">&#39;&lt;/pre&gt;&lt;/div&gt;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Extract our segments from the pygmentized source.</p></div></div><div class="code"><div class="wrapper">      <span class="nv">highlighted = </span><span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">result</span><span class="si">}</span><span class="s">\n&quot;</span><span class="p">.</span><span class="nx">split</span> <span class="sr">/.*&lt;span.*SEGMENT DIVIDER&lt;\/span&gt;.*/</span>

      <span class="k">if</span> <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span> <span class="o">!=</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>
        <span class="nv">error = </span><span class="k">new</span> <span class="nb">Error</span> <span class="nx">utils</span><span class="p">.</span><span class="nx">CompatibilityHelpers</span><span class="p">.</span><span class="nx">format</span> <span class="s">&#39;pygmentize rendered %d of %d segments; expected to be equal&#39;</span><span class="p">,</span>
          <span class="nx">highlighted</span><span class="p">.</span><span class="nx">length</span><span class="p">,</span> <span class="nx">segments</span><span class="p">.</span><span class="nx">length</span>

        <span class="nv">error.pygmentsOutput   = </span><span class="nx">result</span>
        <span class="nv">error.failedHighlights = </span><span class="nx">highlighted</span>
        <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Attach highlighted source to the highlightedCode property of a Segment.</p></div></div><div class="code"><div class="wrapper">      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">segment.highlightedCode = </span><span class="nx">highlighted</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>

      <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Rather than spawning pygments for each segment, we stream it all in, separated by 'magic'
comments so that we can split the highlighted source back into segments.</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>To further complicate things, pygments doesn't let us cheat with indentation-aware languages:
We have to match the indentation of the line following the divider comment.</p></div></div><div class="code"><div class="wrapper">    <span class="nv">mergedCode = </span><span class="s">&#39;&#39;</span>
    <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">segments</span>
      <span class="nv">segmentCode = </span><span class="nx">segment</span><span class="p">.</span><span class="nx">code</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>

      <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;</span> <span class="mi">0</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Double negative: match characters that are spaces but not newlines</p></div></div><div class="code"><div class="wrapper">        <span class="nv">indentation = </span><span class="nx">segmentCode</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^[^\S\n]+/</span><span class="p">)</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">||</span> <span class="s">&#39;&#39;</span>
        <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="s">&quot;\n</span><span class="si">#{</span><span class="nx">indentation</span><span class="si">}#{</span><span class="nx">language</span><span class="p">.</span><span class="nx">singleLineComment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s"> SEGMENT DIVIDER\n&quot;</span>

      <span class="nx">mergedCode</span> <span class="o">+=</span> <span class="nx">segmentCode</span>

    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">write</span> <span class="nx">mergedCode</span>
    <span class="nx">pygmentize</span><span class="p">.</span><span class="nx">stdin</span><span class="p">.</span><span class="nx">end</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Annotate an array of segments by running their comments through
<a href="https://github.com/coreyti/showdown">showdown</a>.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">markdownComments: </span><span class="nf">(segments, project, callback) -&gt;</span>
    <span class="nv">converter = </span><span class="k">new</span> <span class="nx">showdown</span><span class="p">.</span><span class="nx">converter</span><span class="p">()</span>

    <span class="k">try</span>
      <span class="k">for</span> <span class="nx">segment</span><span class="p">,</span> <span class="nx">segmentIndex</span> <span class="k">in</span> <span class="nx">segments</span>
        <span class="nv">markdown = </span><span class="nx">converter</span><span class="p">.</span><span class="nx">makeHtml</span> <span class="nx">segment</span><span class="p">.</span><span class="nx">comments</span><span class="p">.</span><span class="nx">join</span> <span class="s">&#39;\n&#39;</span>
        <span class="nv">headers  = </span><span class="p">[]</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>showdown generates header ids by lowercasing &amp; dropping non-word characters.  We'd like
something a bit more readable.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">markdown = </span><span class="nx">@gsub</span> <span class="nx">markdown</span><span class="p">,</span> <span class="sr">/&lt;h(\d) id=&quot;[^&quot;]+&quot;&gt;([^&lt;]+)&lt;\/h\d&gt;/g</span><span class="p">,</span> <span class="p">(</span><span class="nx">match</span><span class="p">)</span> <span class="o">=&gt;</span>
          <span class="nv">header =</span>
            <span class="nv">level: </span><span class="nb">parseInt</span> <span class="nx">match</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="nv">title: </span><span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="nv">slug: </span> <span class="nx">@slugifyTitle</span> <span class="nx">match</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

          <span class="nv">header.isFileHeader = </span><span class="kc">true</span> <span class="k">if</span> <span class="nx">header</span><span class="p">.</span><span class="nx">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="nx">segmentIndex</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">match</span><span class="p">.</span><span class="nx">index</span> <span class="o">==</span> <span class="mi">0</span>

          <span class="nx">headers</span><span class="p">.</span><span class="nx">push</span> <span class="nx">header</span>

          <span class="s">&quot;&lt;h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s"> id=\&quot;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">slug</span><span class="si">}</span><span class="s">\&quot;&gt;</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="s">&lt;/h</span><span class="si">#{</span><span class="nx">header</span><span class="p">.</span><span class="nx">level</span><span class="si">}</span><span class="s">&gt;&quot;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>We attach the rendered markdown to the comment</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.markdownedComments = </span><span class="nx">markdown</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>As well as the extracted headers to aid in outline building.</p></div></div><div class="code"><div class="wrapper">        <span class="nv">segment.headers = </span><span class="nx">headers</span>

    <span class="k">catch</span> <span class="nx">error</span>
      <span class="k">return</span> <span class="nx">callback</span> <span class="nx">error</span>

    <span class="nx">callback</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Sometimes you just don't want any of them hanging around.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">trimBlankLines: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^[\r\n]+/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[\r\n]+$/</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Given a title, convert it into a URL-friendly slug.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">slugifyTitle: </span><span class="nf">(string) -&gt;</span>
    <span class="nx">string</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="sr">/[\s\-\_]+/</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span> <span class="nf">(s) -&gt;</span> <span class="nx">s</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/[^\w]/g</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">).</span><span class="nx">toLowerCase</span><span class="p">()</span> <span class="p">).</span><span class="nx">join</span> <span class="s">&#39;-&#39;</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>replacer is a function that is given the match object, and returns the string to replace with.</p></div></div><div class="code"><div class="wrapper">  <span class="nv">gsub: </span><span class="nf">(string, matcher, replacer) -&gt;</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span> <span class="s">&#39;You must pass a global RegExp to gsub!&#39;</span> <span class="nx">unless</span> <span class="nx">matcher</span><span class="p">.</span><span class="nx">global</span><span class="o">?</span>

    <span class="nv">result = </span><span class="s">&#39;&#39;</span>
    <span class="nv">matcher.lastIndex = </span><span class="mi">0</span>
    <span class="nv">furthestIndex = </span><span class="mi">0</span>

    <span class="k">while</span> <span class="p">(</span><span class="nv">match = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">exec</span> <span class="nx">string</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">null</span>
      <span class="nx">result</span> <span class="o">+=</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...</span><span class="nx">match</span><span class="p">.</span><span class="nx">index</span><span class="p">]</span> <span class="o">+</span> <span class="nx">replacer</span> <span class="nx">match</span>

      <span class="nv">furthestIndex = </span><span class="nx">matcher</span><span class="p">.</span><span class="nx">lastIndex</span>

    <span class="nx">result</span> <span class="o">+</span> <span class="nx">string</span><span class="p">[</span><span class="nx">furthestIndex</span><span class="p">...]</span></div></div></div></div></body></html>